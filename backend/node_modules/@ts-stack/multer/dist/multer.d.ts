import { Strategy, MulterGroup, MulterLimits, NormalizedLimits, MulterOptions, MulterParser } from './types.js';
export declare class Multer {
    #private;
    constructor(options?: MulterOptions);
    /**
     * Accepts a single file from a form field with the name you pass in the `name` parameter.
     * The single file will be stored in `parsedForm.file` property.
     */
    single<F extends object = any>(name: string): MulterParser<F, never>;
    /**
     * Accepts an array of files from a form field with the name you pass in the `name` parameter.
     * Optionally error out if more than `maxCount` files are uploaded. The array of files will be
     * stored in `parsedForm.files` property.
     *
     * __Note__: `maxCount` limit has precedence over `limits.files`.
     */
    array<F extends object = any>(name: string, maxCount?: number): MulterParser<F, never>;
    /**
     * Accepts groups of file arrays with fields of the form you specify with the `group` parameter.
     * An object with arrays of files will be stored in `parsedForm.groups` property.
     *
     * `groups` should be an array of objects with `name` and optionally a `maxCount`.
     * Example:
     *
  ```ts
  [
    { name: 'avatar', maxCount: 1 },
    { name: 'gallery', maxCount: 8 }
  ]
  ```
     *
     * __Note__: `maxCount` limit has precedence over `limits.files`.
     */
    groups<F extends object = any, G extends string = string>(groups: MulterGroup<G>[]): MulterParser<F, G>;
    /**
     * Accept only text (non-file) fields. If any file upload is made, error with code
     * `LIMIT_UNEXPECTED_FILE` will be issued. This is the same as doing `parse.groups([])`.
     */
    textFields<F extends object = any>(): MulterParser<F, never>;
    /**
     * Accepts arrays of files from any form fields, with no limit on the number of files.
     * An array of files will be stored in `parsedForm.files`.
     *
     * **WARNING:** Make sure that you always handle the files that a user uploads.
     * Never use this method as a global parser since a malicious user could upload
     * files to a route that you didn't anticipate. Only use this function on routes
     * where you are handling the uploaded files.
     */
    any<F extends object = any>(): MulterParser<F, never>;
    protected normalizeLimits(options: MulterOptions): void;
    protected parseLimit(limits: MulterLimits, key: keyof MulterLimits, defaultValue: string | number): number;
    protected handle(limits: NormalizedLimits, groups: MulterGroup[], fileStrategy: Strategy, withoutGuard?: boolean): (req: import("stream").Readable, headers: import("http").IncomingHttpHeaders) => Promise<false | import("./types.js").MulterParsedForm | null>;
}
//# sourceMappingURL=multer.d.ts.map