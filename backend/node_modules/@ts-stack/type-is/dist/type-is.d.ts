/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
import { IncomingHttpHeaders } from 'node:http';
/**
 * Compare a `actual` content-type with `acceptable`.
 * Each `acceptable` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 */
export declare function is(actual?: any, ...acceptable: string[]): string | false;
export declare function is(actual?: any, acceptable?: string[]): string | false;
/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 */
export declare function hasBody(headers: IncomingHttpHeaders): boolean;
/**
 * Check if the `headers` contains the "Content-Type"
 * field, and it contains any of the give mime `acceptable` types.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     typeIs(headers, 'html'); // => 'html'
 *     typeIs(headers, 'text/html'); // => 'text/html'
 *     typeIs(headers, 'text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     typeIs(headers, 'json', 'urlencoded'); // => 'json'
 *     typeIs(headers, 'application/json'); // => 'application/json'
 *     typeIs(headers, 'html', 'application/*'); // => 'application/json'
 *
 *     typeIs(headers, 'html'); // => false
 */
export declare function typeIs(headers: IncomingHttpHeaders, ...acceptable: string[]): string | false | null;
export declare function typeIs(headers: IncomingHttpHeaders, acceptable?: string[]): string | false | null;
/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
```ts
const type = is(headers, ['urlencoded', 'json', 'multipart']);
```
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 */
export declare function normalize(type: string): string | false | null;
/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 */
export declare function mimeMatch(expected: string | false, actual: string): boolean;
//# sourceMappingURL=type-is.d.ts.map